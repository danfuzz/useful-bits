#!/bin/bash
#
# Copyright 2022 Dan Bornstein.
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Library for reasonably okay argument / option processing.
#

# Processes all of the given arguments, according to the configured handlers.
# Returns non-zero if there is trouble parsing options or if any handler returns
# non-zero.
#
# Note: In addition to handlers defined by `opt-switch`, and `opt-value`, the
# handler `arg-rest`, if defined, is called with all arguments that remain after
# option processing. If not defined, it is considered an error to pass any
# non-option arguments.
function process-args {
    local argError=0
    local arg handler name value

    while (( $# > 0 )); do
        arg="$1"

        if [[ ${arg} == '--' ]]; then
            # Explicit end of options.
            shift
            break
        elif [[ ${arg} == '-' || ${arg} =~ ^[^-] ]]; then
            # Non-option argument.
            break
        elif [[ ${arg} =~ ^--([-a-zA-Z0-9]+)(=.*)?$ ]]; then
            # Long-form argument.
            name="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"
            handler="_opt-long-${name}"
            if ! declare -F "${handler}" >/dev/null; then
                echo 1>&2 "Unknown option: --${name}"
                argError=1
            elif [[ ${value} == '' ]]; then
                "${handler}" || argError=1
            else
                # `:1` to drop the `=` from the start of `value`
                "${handler}" "${value:1}" || argError=1
            fi
        elif [[ $arg =~ ^-([a-zA-Z0-9]+)$ ]]; then
            # Short-form argument.
            arg="${BASH_REMATCH[1]}"
            while [[ ${arg} =~ ^(.)(.*)$ ]]; do
                name="${BASH_REMATCH[1]}"
                arg="${BASH_REMATCH[2]}"
                handler="_opt-shortcut-${name}"
                if ! declare -F "${handler}" >/dev/null; then
                    echo 1>&2 "Unknown option: -${name}"
                    argError=1
                    # Break, to avoid spewing a ton of errors in case of a
                    # pilot error along the lines of `-longOptionName`.
                    break
                else
                    "${handler}" || argError=1
                fi
            done
        else
            # Something weird and invalid, e.g. `--=`.
            echo 1>&2 "Invalid option: ${arg}"
            argError=1
        fi

        shift
    done

    if declare -F arg-rest >/dev/null; then
        arg-rest "$@" || argError=1
    elif (( $# > 0 )); then
        echo 1>&2 'Non-option arguments are not allowed.'
        argError=1
    fi

    return "${argError}"
}

# Declares an "action" option. If a slash and single character are appended to
# the option name, that is taken to be a shortcut to activate the option. At
# least one of the two options must be specified.
#
# --call=<name> -- Calls the function with the given name. If `--var` is also
#   used, the variable is set before the call is made.
# --var=<name> -- Sets the global `<name>` to `1`, and causes it to be
#   defaulted to `0` at the start of argument processing.
function opt-action {
    local callFunc=''
    local setVar=''

    while (( $# > 0 )); do
        case "$1" in
            --call=?*)
                callFunc="${1#*=}"
                ;;
            --var=?*)
                setVar="${1#*=}"
                ;;
            *)
                # End of options / unrecognized option.
                break
                ;;
        esac
        shift
    done

    local name="$1"

    if ! [[ ${name} =~ ^([a-zA-Z0-9][-a-zA-Z0-9]*)(/[a-zA-Z0-9])?$ ]]; then
        echo 1>&2 "Invalid action-option name: ${name}"
        return 1
    fi

    name="${BASH_REMATCH[1]}"
    local shortcut="${BASH_REMATCH[2]}"

    if [[ ${callFunc} == '' && ${setVar} == '' ]]; then
        echo 1>&2 "Must use at least one of --call or --var for option: ${name}."
        return 1
    fi

    if [[ ${setVar} != '' ]]; then
        # Default the variable to `0`, and then re-form as the setter code.
        eval "${setVar}=0"
        setVar="${setVar}=1"
    fi

    eval 'function _opt-long-'"${name}"' {
        if (( $# > 0 )); then
            echo 1>&2 "Value not allowed for option: --'"${name}"'"
            return 1
        fi

        '"${setVar}"'
        '"${callFunc}"'
    }'

    if (( ${#shortcut} == 2 )); then
        # `:1` to drop the slash.
        eval 'function _opt-shortcut-'"${shortcut:1}"' {
            _opt-long-'"${name}"' "$@"
        }'
    fi
}

# Declares a "toggle" option, which can be turned on with `--<name>` or off with
# `--no-<name>`. If a slash and single character are appended to the option
# name, that is taken to be a shortcut to turn the toggle on. Likewise, a second
# slash and character indicate a shortcut to turn the toggle off. At least one
# of the two options must be specified.
#
# --call=<name> -- Calls the function with the given name, passing it `1` or
#   `0`. If `--var` is also used, the variable is set before the call is made.
# --var=<name> -- Sets the global `<name>` to `1` or `0`, and causes it to be
#   defauled to `0` at the start of argument processing.
function opt-toggle {
    local callFunc=''
    local setVar=''

    while (( $# > 0 )); do
        case "$1" in
            --call=?*)
                callFunc="${1#*=}"
                ;;
            --var=?*)
                setVar="${1#*=}"
                ;;
            *)
                # End of options / unrecognized option.
                break
                ;;
        esac
        shift
    done

    local name="$1"

    if ! [[ ${name} =~ ^([a-zA-Z0-9][-a-zA-Z0-9]*)(/[a-zA-Z0-9]?)?(/[a-zA-Z0-9])?$ ]]; then
        echo 1>&2 "Invalid toggle-option name: ${name}"
        return 1
    fi

    name="${BASH_REMATCH[1]}"
    local shortcutOn="${BASH_REMATCH[2]}"
    local shortcutOff="${BASH_REMATCH[3]}"

    if [[ ${callFunc} == '' && ${setVar} == '' ]]; then
        echo 1>&2 "Must use at least one of --call or --var for option: ${name}."
        return 1
    fi

    if [[ ${setVar} != '' ]]; then
        # Default the variable to `0`, and then re-form as the setter code.
        eval "${setVar}=0"
        setVar="${setVar}"'="${value}"'
    fi

    if [[ ${callFunc} != '' ]]; then
        # Re-form as the caller code.
        callFunc="${callFunc}"' "${value}"'
    fi

    eval '
        function _opt-toggle-handler-'"${name}"' {
            local value="$1"

            if (( $# > 1 )); then
                echo 1>&2 "Value not allowed for option: --'"${name}"'"
                return 1
            fi

            '"${setVar}"'
            '"${callFunc}"'
        }

        function _opt-long-'"${name}"' {
            _opt-toggle-handler-'"${name}"' 1 "$@"
        }

        function _opt-long-no-'"${name}"' {
            _opt-toggle-handler-'"${name}"' 0 "$@"
        }
    '

    if (( ${#shortcutOn} == 2 )); then
        # `:1` to drop the slash.
        eval 'function _opt-shortcut-'"${shortcutOn:1}"' {
            _opt-toggle-handler-'"${name}"' 1
        }'
    fi

    if (( ${#shortcutOff} == 2 )); then
        # `:1` to drop the slash.
        eval 'function _opt-shortcut-'"${shortcutOff:1}"' {
            _opt-toggle-handler-'"${name}"' 0
        }'
    fi
}

# Declares a "value" option, which takes a value via the form
# `--<name>=<value>`. At least one of the two options `--call` or `--var` must
# be specified. Others are optional.
#
# --call=<name> -- Calls the function with the given name, passing it the option
#   value parsed from the argument. If `--var` is also used, the variable is set
#   before the call is made.
# --default=<value> -- The default value for the variable.
# --match=<regex> -- Regular expression matched against the entire argument
#   value. If the value does not match, then the option gets rejected.
# --var=<name> -- Sets the global `<name>` to the value parsed from the
#   argument. This also causes the variable to be initialized (to `''` by
#   default) at the start of argument processing.
function opt-value {
    local callFunc=''
    local defaultValue=''
    local match=''
    local setVar=''

    while (( $# > 0 )); do
        case "$1" in
            --call=?*)
                callFunc="${1#*=}"
                ;;
            --default=?*)
                defaultValue="${1#*=}"
                ;;
            --match=?*)
                match="${1#*=}"
                ;;
            --var=?*)
                setVar="${1#*=}"
                ;;
            *)
                # End of options / unrecognized option.
                break
                ;;
        esac
        shift
    done

    local name="$1"

    if ! [[ ${name} =~ ^[a-zA-Z0-9][-a-zA-Z0-9]*$ ]]; then
        echo 1>&2 "Invalid value-option name: ${name}"
        return 1
    fi

    if [[ ${callFunc} == '' && ${setVar} == '' ]]; then
        echo 1>&2 "Must use at least one of --call or --var for option: ${name}."
        return 1
    fi

    if [[ ${setVar} != '' ]]; then
        # Re-form these as the defaulter and setter code (respectively).
        defaultVar="${setVar}=$(printf '%q' "${defaultValue}")"
        setVar="${setVar}"'="${value}"'
        eval "${defaultVar}"
    fi

    if [[ ${callFunc} != '' ]]; then
        # Re-form as the caller code.
        callFunc="${callFunc}"' "${value}"'
    fi

    if [[ ${match} != '' ]]; then
        # Re-form as the clause to insert to perform the check.
        match='
            elif ! [[ ${value} =~ ^('"${match}"')$ ]]; then
                echo 1>&2 "Invalid value for option: --${name}"
                echo 1>&2 "Value: ${value}"
                return 1'
    fi

    eval 'function _opt-long-'"${name}"' {
        local value="$1"

        if (( $# < 1 )); then
            echo 1>&2 "Value required for option: --'"${name}"'"
            return 1
        '"${match}"'
        fi

        '"${setVar}"'
        '"${callFunc}"'
    }'
}


#
# Library-internal functions
#


#
# TEST
#

opt-toggle --var=progress progress/p/P

opt-value --match='[a-z][-a-z0-9]*' --var=inLocation --call=set-location in
function set-location {
    echo 1>&2 ">>> SET LOCATION <<< ${inLocation} $1"
}
echo 1>&2 "#### LOCATION START ${inLocation}"

opt-value --var=namex --default='no name' name
echo 1>&2 "#### NAME START ${namex}"

opt-action --call=usage --var=wantHelp help/h
function usage {
    echo 1>&2 '>>> THIS IS YOUR HELP! <<<' "${wantHelp}"
    exit
}

args=()
function arg-rest {
    echo "#### rest $#"
    if (( $# > 0 )); then
        printf $'>>%q<<\n' "$@"
    fi
}

echo 1>&2 '########## A'
process-args "$@"
error="$?"
echo 1>&2 "##### error? ${error}"
echo 1>&2 '########## B'

echo 1>&2 "#### progress ${progress}"
echo 1>&2 "#### in ${inLocation}"
echo 1>&2 "#### name ${namex}"

if (( error )); then
    exit "${error}"
fi

if [[ ${inLocation} == '' ]]; then
    echo 1>&2 'Missing required option: --in'
fi
