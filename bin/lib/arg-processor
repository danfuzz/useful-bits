#!/bin/bash
#
# Copyright 2022 Dan Bornstein.
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Library for reasonably okay argument / option processing.
#
# Option processing is done in the common style with double-dashes to pass long
# options, which can optionally be passed values after an `=`, e.g. `--foo` for
# a valueless option and `--bar=zorch` for one with a value. The argument `--`
# indicates the explicit end of options, and single dash (`-`) and negative
# integers (e.g. `-123`) are interpreted as non-option arguments.
#
# The public argument-defining functions all take argument specifications of the
# form `<name>/<abbrev>=<value>`. `<name>` is the argument (long option) name.
# `<abbrev>` is a one-letter abbreviation for a single-dash option form.
# `<value>` is a (string) value to associate with the argument. `<abbrev>` and
# `<value>` are always optional and (independently) sometimes prohibited,
# depending on the definition function.
#
# The public argument-defining functions also all take two options,
# `--call=<name>` and `--var=<name>`, at least one of which must be passed.
# `--call` specifies a function to be called when parsing an argument, and
# `--var` specifies a variable to set. If both are used, then the call is made
# first, and the variable is only set if the call returns successfully. The
# variable, if specified, is always initialized to a default value, which is
# itself optionally specified via `--default=<value>`. If `--default` isn't
# used, then the default-for-the-default depends on the specific function.
#
# Definers for value-accepting arguments take an option `--filter=<spec>`, which
# specifies either a function to call or a regular expression to match against
# the argument value. If the call or match fails, the argument isn't accepted.
# In addition, the function form is expected to output the value to use on
# success (e.g. a replacement for what was directly passed on the commandline).
# Note: Because a filter function's output is captured, it runs in a subshell,
# and as such it cannot be used to affect the global environment of the main
# script.
#
# Some argument-definers also accept `--required`, to indicate that the argument
# or option is required (mandatory).
#
# Beyond the above, see the docs for the functions for restrictions and
# additional options.

# List of statements to run just before parsing. This includes:
#
# * global variable assignment statements
# * required option "got the option" initializers
_argproc_initStatements=()

# List of functions to run to parse positional arguments.
_argproc_positionalFuncs=()

# List of statements to run after parsing, to do pre-return validation. This
# includes:
#
# * required option "got the option" checkers
_argproc_preReturnStatements=()


#
# Public functions
#
# Note: In places where this code expects to set global variables and call back
# to client code, care is taken to only define local variables with names that
# are unlikely to shadow globals. ("Hooray" for dynamic scoping!)
#

# Declares an "action" option, which takes no value on a commandline. If left
# unspecified, the default variable value for an action option is `0`, and the
# default activation value is `1`.
function opt-action {
    local optCall=''
    local optDefault='0'
    local optVar=''
    local args=("$@")
    _argproc_janky-args call default var \
    || return 1

    local specName=''
    local specAbbrev=''
    local specHasValue=0 # Ignored, but needed because `parse-spec` will set it.
    local specValue='1'
    _argproc_parse-spec --abbrev --value "${args[0]}" \
    || return 1

    _argproc_define-no-value-arg --option \
        "${specName}" "${optCall}" "${optVar}" "${specAbbrev}" "${specValue}"

    if [[ ${optVar} != '' ]]; then
        # Set up the default initializer.
        _argproc_initStatements+=("${optVar}=$(_argproc_quote "${optDefault}")")
    fi
}

# Declares a "choice" option set, consisting of one or more options. On a
# commandline, no choice option accepts a value (because the option name itself
# implies the value). If left unspecified, the default variable value for a
# choice option is `''` (the empty string). This definer also accepts the
# `--required` option.
function opt-choice {
    local optCall=''
    local optDefault=''
    local optRequired=0
    local optVar=''
    local args=("$@")
    _argproc_janky-args --multi-spec call default required var \
    || return 1

    if [[ ${optVar} != '' ]]; then
        # Set up the default initializer.
        _argproc_initStatements+=("${optVar}=$(_argproc_quote "${optDefault}")")
    fi

    local allNames=()
    local spec
    for spec in "${args[@]}"; do
        local specName=''
        local specAbbrev=''
        local specHasValue=0
        local specValue=''
        _argproc_parse-spec --abbrev --value "${spec}" \
        || return 1

        if (( !specHasValue )); then
            specValue="${specName}"
        fi

        _argproc_define-no-value-arg --option \
            "${specName}" "${optCall}" "${optVar}" "${specAbbrev}" "${specValue}"

        allNames+=("${specName}")
    done

    if (( optRequired )); then
        _argproc_add-required-arg-postcheck "${allNames[@]}"
    fi
}

# Declares a "toggle" option, which does not accept a value on the commandline.
# No `<value>` is allowed in the argument spec. The toggle state of off or on is
# always indicated by a value of `0` or `1` (respectively). In addition to the
# main long-form option `--<name>`, this function also defines `--no-<name>` to
# turn the toggle off. If left unspecified, the default variable value for a
# toggle option is `0`.
function opt-toggle {
    local optCall=''
    local optVar=''
    local args=("$@")
    _argproc_janky-args call var \
    || return 1

    local specName=''
    local specAbbrev=''
    _argproc_parse-spec --abbrev "${args[0]}" \
    || return 1

    if [[ ${optVar} != '' ]]; then
        # Set up the default initializer.
        _argproc_initStatements+=("${optVar}=0")
    fi

    _argproc_define-no-value-arg --option \
        "${specName}" "${optCall}" "${optVar}" "${specAbbrev}" '1'
    _argproc_define-no-value-arg --option \
        "no-${specName}" "${optCall}" "${optVar}" '' '0'

    if [[ ${specAbbrev} != '' ]]; then
        _argproc_define-abbrev "${specAbbrev}" "${specName}"
    fi
}

# Declares a "value" option, which requires a value when passed on a
# commandline. No `<abbrev>` or `<value>` is allowed in the argument spec. If
# left unspecified, the default variable value for a value option is `''` (the
# empty string). This definer also accepts the `--required` and `--filter`
# options.
function opt-value {
    local optCall=''
    local optDefault=''
    local optFilter=''
    local optRequired=0
    local optVar=''
    local args=("$@")
    _argproc_janky-args call default filter required var \
    || return 1

    local specName=''
    _argproc_parse-spec "${args[0]}" \
    || return 1

    if [[ ${optVar} != '' ]]; then
        # Set up the default initializer.
        _argproc_initStatements+=("${optVar}=$(_argproc_quote "${optDefault}")")
    fi

    _argproc_define-value-required-arg --option \
        "${specName}" "${optCall}" "${optVar}" "${optFilter}"

    if (( optRequired )); then
        _argproc_add-required-arg-postcheck "${specName}"
    fi
}

# Declares a positional argument. No `<abbrev>` or `<value>` is allowed in the
# argument spec. Unlike options, a positional argument name is _only_ used for
# error messages and internal bookkeeping. This definer also accepts the
# `--required` and `--filter` options.
function positional-arg {
    local optCall=''
    local optDefault=''
    local optFilter=''
    local optRequired=0
    local optVar=''
    local args=("$@")
    _argproc_janky-args call default filter required var \
    || return 1

    local specName=''
    _argproc_parse-spec "${args[0]}" \
    || return 1

    if [[ ${optVar} != '' ]]; then
        # Set up the default initializer.
        _argproc_initStatements+=("${optVar}=$(_argproc_quote "${optDefault}")")
    fi

    _argproc_define-value-required-arg \
        "${specName}" "${optCall}" "${optVar}" "${optFilter}"

    if (( optRequired )); then
        _argproc_add-required-arg-postcheck "${specName}"
    fi

    _argproc_positionalFuncs+=("_argproc:positional-${specName}")
}

# Prints a usage message. This is just a convenient shorthand to do just a few
# things to a given literal string:
#
# * Trim away empty lines at the start and end of the string.
# * Trim away whitespace from the start of lines, based on the indentation of
#   the first not-just-whitespace line.
# * Substitute the name of the program for the variable-like string `${name}`.
# * Print to `stderr`.
function print-usage {
    local msg="$1"

    awk 2>&1 <<<"${msg}" -v name="${progName}" \
    '
    BEGIN {
        atStart = 1;
        blankCount = 0;
        indentExpr = ""; # Regex to match indentation to strip.
    }

    # Count blank lines, but do not emit them.
    /^[ \t]*$/ {
        blankCount++;
        next;
    }

    blankCount != 0 {
        if (!atStart) {
            # Emit some blank lines in the middle of the message. (Ignore them
            # at the start of the message.)
            while (blankCount-- > 0) print "";
        }
        blankCount = 0;
    }

    # Determine first-line indentation; convert to regex.
    indentExpr == "" {
        match($0, /^[ \t]*/);
        indentExpr = "^" substr($0, 1, RLENGTH);
    }

    {
        atStart = 0;
        sub(indentExpr, "");
        gsub(/\${name}/, name);
        print;
    }
    '
}

# Processes all of the given arguments, according to the configured handlers.
# Returns non-zero if there is trouble parsing options or if any handler returns
# non-zero.
#
# Note: In addition to handlers defined by `opt-switch`, and `opt-value`, the
# handler `arg-rest`, if defined, is called with all arguments that remain after
# option processing. If not defined, it is considered an error to pass any
# non-option arguments.
function process-args {
    local _argproc_error=0
    local _argproc_s

    # Run all the pre-parse statements.
    for _argproc_s in "${_argproc_initStatements[@]}"; do
        eval "${_argproc_s}"
    done

    # Build up the statements to evaluate, and evaluate them.
    local _argproc_statements=()
    _argproc_statements-from-args "$@" \
    || _argproc_error="$?"

    for _argproc_s in "${_argproc_statements[@]}"; do
        eval "${_argproc_s}" || _argproc_error="$?"
    done

    if (( _argproc_error )); then
        # Don't continue if there were problems above, because that will lead to
        # spurious extra errors (e.g. "missing" a required option that was
        # present but didn't pass a validity check).
        return "${_argproc_error}"
    fi

    # Do any post-parse checks.
    for _argproc_s in "${_argproc_preReturnStatements[@]}"; do
        eval "${_argproc_s}" || _argproc_error="$?"
    done

    return "${_argproc_error}"
}

# Requires that exactly one of the indicated arguments / options is present.
function require-exactly-one-arg-of {
    local args=("$@")
    _argproc_janky-args --multi-spec \
    || return 1

    local allNames=()
    local spec
    for spec in "${args[@]}"; do
        local specName=''
        _argproc_parse-spec "${spec}" \
        || return 1

        allNames+=("${specName}")
    done

    _argproc_add-required-arg-postcheck --exactly-one "${allNames[@]}"
}

# Declares a "rest" argument, which gets all the non-option and non-positional
# arguments, during parsing. If this is not declared, argument processing will
# report an error in the presence of any "rest" arguments.
function rest-arg {
    local optCall=''
    local optVar=''
    local args=("$@")
    _argproc_janky-args call var \
    || return 1

    if [[ ${optCall} != '' ]]; then
        # Re-form as the caller code.
        optCall="${optCall}"' "$@" || return "$?"'
    fi

    if [[ ${optVar} != '' ]]; then
        # Set up the default initializer, and then re-form as the setter code.
        _argproc_initStatements+=("${optVar}=()")
        optVar="${optVar}"'=("$@")'
    fi

    eval 'function _argproc:rest {
        '"${optCall}"'
        '"${optVar}"'
    }'
}


#
# Library-internal functions
#

# Adds a pre-return check which fails if none of the indicated arguments/options
# was present on the commandline, and optionally if more than exactly one was
# present.
function _argproc_add-required-arg-postcheck {
    local exactlyOne=0
    if [[ $1 == '--exactly-one' ]]; then
        exactlyOne=1
        shift
    fi

    _argproc_preReturnStatements+=('local _argproc_count=0')

    local argNoun='option'
    local allNames=''

    local longName
    for longName in "$@"; do
        _argproc_preReturnStatements+=("$(
            printf '[[ ${_argproc_receivedArgNames} =~ "<%s>" ]] && (( _argproc_count++ )) || true' \
                "${longName}"
        )")

        local desc="$(_argproc_arg-description --short "${longName}")"
        if ! [[ ${desc} =~ - ]]; then
            argNoun='argument'
        fi

        allNames+=" ${desc}"
    done

    local errorMsg

    if (( exactlyOne )); then
        errorMsg="Too many ${argNoun}s from set:${allNames}"
        _argproc_preReturnStatements+=("$(
            printf '(( _argproc_count <= 1 )) || { echo 1>&2 %q; false; }' \
                "${errorMsg}"
        )")
    fi

    if (( $# == 1 )); then
        errorMsg="Missing required ${argNoun}${allNames}."
    else
        errorMsg="Missing required ${argNoun} from set:${allNames}"
    fi

    _argproc_preReturnStatements+=(
        "$(printf $'(( _argproc_count != 0 )) || { echo 1>&2 %q; false; }\n' \
            "${errorMsg}"
    )")
}

# Gets the description of the named argument.
function _argproc_arg-description {
    local short=0
    if [[ $1 == '--short' ]]; then
        short=1
        shift
    fi

    local longName="$1"
    local funcName="_argproc:arg-description-${longName}"
    local desc

    desc="$("${funcName}")" \
    || return 1

    if (( short )); then
        echo "${desc/* /}"
    else
        echo "${desc}"
    fi
}

# Defines an "abbrev" function, which is what gets called to activate a
# short-form option.
function _argproc_define-abbrev {
    local abbrevChar="$1"
    local longName="$2"

    eval 'function _argproc:abbrev-'"${abbrevChar}"' {
        _argproc:long-'"${longName}"' "$@"
    }'
}

# Defines an argument activation function which prohibits passing a value, as
# the value is "built into" the argument spec.
function _argproc_define-no-value-arg {
    if [[ $1 == '--option' ]]; then
        shift
    else
        # `--option` is really defined here for parallel structure, not utility.
        echo 1>&2 'Not supported.'
        return 1
    fi

    local longName="$1"
    local callFunc="$2"
    local varName="$3"
    local abbrevChar="$4"
    local value="$5"

    value="$(_argproc_quote "${value}")"

    _argproc_set-arg-description "${longName}" option \
    || return 1

    if [[ ${callFunc} != '' ]]; then
        # Re-form as the caller code.
        callFunc="${callFunc} ${value}"' || return "$?"'
    fi

    if [[ ${varName} != '' ]]; then
        # Re-form as the setter code.
        varName="${varName}=${value}"
    fi

    eval 'function _argproc:long-'"${longName}"' {
        if (( $# > 0 )); then
            echo 1>&2 "Value not allowed for option --'"${longName}"'."
            return 1
        fi

        '"${callFunc}"'
        '"${varName}"'
        _argproc_receivedArgNames+="<'"${longName}"'>"
    }'

    if [[ ${abbrevChar} != '' ]]; then
        _argproc_define-abbrev "${abbrevChar}" "${longName}"
    fi
}

# Defines an argument/option activation function which requires passing a value.
function _argproc_define-value-required-arg {
    local isOption=0
    if [[ $1 == '--option' ]]; then
        isOption=1
        shift
    fi

    local longName="$1"
    local callFunc="$2"
    local varName="$3"
    local filter="$4"

    local desc handlerName
    if (( isOption )); then
        _argproc_set-arg-description "${longName}" option || return 1
        desc="option --${longName}"
        handlerName="_argproc:long-${longName}"
    else
        _argproc_set-arg-description "${longName}" argument || return 1
        desc="argument <${longName}>"
        handlerName="_argproc:positional-${longName}"
    fi

    if [[ ${callFunc} != '' ]]; then
        # Re-form as the caller code.
        callFunc="${callFunc}"' "${_argproc_value}" || return "$?"'
    fi

    if [[ ${varName} != '' ]]; then
        # Re-form as the setter code.
        varName="${varName}"'="${_argproc_value}"'
    fi

    if [[ ${filter} =~ ^/(.*)/$ ]]; then
        # Re-form `filter` as the statement which performs the regex check.
        filter="${BASH_REMATCH[1]}"
        filter='
            if ! [[ ${_argproc_value} =~ '"${filter}"' ]]; then
                echo 1>&2 "Invalid value for '"${desc}"': ${_argproc_value}"
                return 1
            fi'
    elif [[ ${filter} != '' ]]; then
        # Re-form `filter` as the call to the filter function.
        filter='_argproc_value="$('"${filter}"' "${_argproc_value}")" || return 1'
    fi

    eval 'function '"${handlerName}"' {
        if (( $# < 1 )); then
            echo 1>&2 "Value required for '"${desc}"'."
            return 1
        fi
        local _argproc_value="$1"
        '"${filter}"'
        '"${callFunc}"'
        '"${varName}"'
        _argproc_receivedArgNames+="<'"${longName}"'>"
    }'

    if [[ ${abbrevChar} != '' ]]; then
        _argproc_define-abbrev "${abbrevChar}" "${longName}"
    fi
}

# Janky yet reasonable argument parser for the commands in this library. (How
# meta!) Takes a list of option names to accept, each of which is parsed in a
# standard way (e.g. `var` is always a variable name, etc.). Sets `opt<Name>`
# (presumed to be a local variable declared in the calling scope) for each
# parsed option. Assumes the variable `args` (again presumed local to the
# caller) contains all the arguments, which gets updates by this function.
# After option parsing, this expects there to be one argument remaining, except
# if `--multi-spec` is passed to this function, in which case there must be at
# least one.
function _argproc_janky-args {
    multiSpec=0
    if [[ $1 == '--multi-spec' ]]; then
        multiSpec=1
        shift
    fi

    local argError=0
    local argSpecs=" $* " # Spaces on the ends to make the match code work.
    local optsDone=0
    local a

    for a in "${args[@]}"; do
        if (( optsDone )); then
            args+=("${a}")
            continue
        fi

        if [[ ${a} =~ ^--. ]]; then
            if ! [[ ${a} =~ ^--([a-z]+)(=.*)?$ ]]; then
                echo 1>&2 "Invalid option syntax: ${a}"
                return 1
            fi

            local name="${BASH_REMATCH[1]}"
            local value="${BASH_REMATCH[2]}"

            if ! [[ ${argSpecs} =~ " ${name} " ]]; then
                echo 1>&2 "Unknown option: --${name}"
                return 1
            fi

            case "${name}" in
                call)
                    [[ ${value} =~ ^=([_a-zA-Z][-_:a-zA-Z0-9]*)$ ]] \
                    && optCall="${BASH_REMATCH[1]}" \
                    || argError=1
                    ;;
                default)
                    [[ ${value} =~ ^=(.*)$ ]] \
                    && optDefault="${BASH_REMATCH[1]}" \
                    || argError=1
                    ;;
                filter)
                    [[ ${value} =~ ^=(/(.*)/|[_a-zA-Z][-_:a-zA-Z0-9]*)$ ]] \
                    && optFilter="${BASH_REMATCH[1]}" \
                    || argError=1
                    ;;
                required)
                    [[ ${value} == '' ]] \
                    && optRequired=1 \
                    || argError=1
                    ;;
                var)
                    [[ ${value} =~ ^=([_a-zA-Z][_a-zA-Z0-9]*)$ ]] \
                    && optVar="${BASH_REMATCH[1]}" \
                    || argError=1
                    ;;
                *)
                    echo 1>&2 "Unknown arg-processing option: --${name}"
                    return 1
                    ;;
            esac

            if (( argError )); then
                if [[ ${value} != '' ]]; then
                    echo 1>&2 "Invalid value for option --${name}: ${value:1}"
                else
                    echo 1>&2 "Value required for option --${name}."
                fi
                return 1
            fi
        elif [[ ${a} == '--' ]]; then
            # Explicit end of options.
            args=()
            optsDone=1
        elif [[ (${a} == '-') || (${a:0:1} != '-') ]]; then
            # Non-option argument.
            args=("${a}")
            optsDone=1
        else
            echo 1>&2 "Invalid option syntax: ${a}"
            return 1
        fi
   done

   # Special case for `--call` and `--var` (which always go together).
   if [[ ${argSpecs} =~ ' call '|' var ' ]]; then
       if [[ (${optCall} == '') && (${optVar} == '') ]]; then
           echo 1>&2 'Must use at least one of --call or --var.'
           return 1
       fi
   fi

   if (( ${#args[@]} == 0 )); then
       echo 1>&2 'Missing specification.'
       return 1
   elif (( ${#args[@]} > 1 && !multiSpec )); then
       echo 1>&2 'Too many specifications.'
       return 1
   fi
}

# Parses a single argument / option spec. `--abbrev` to accept an abbreviation.
# `--value` to accept a value. Sets `spec<Item>` (presumed locals in the calling
# scope) to "return" results.
function _argproc_parse-spec {
    local abbrevOk=0
    local valueOk=0
    while [[ $1 =~ ^--(value|abbrev) ]]; do
        if [[ $1 == '--abbrev' ]]; then
            abbrevOk=1
        else
            valueOk=1
        fi
        shift
    done

    local spec="$1"

    if ! [[ ${spec} =~ ^([a-zA-Z0-9][-a-zA-Z0-9]*)(/[a-zA-Z])?(=.*)?$ ]]; then
        echo 1>&2 "Invalid spec: ${spec}"
        return 1
    fi

    specName="${BASH_REMATCH[1]}" # Name always allowed. Others need to be checked.
    local abbrev="${BASH_REMATCH[2]}"
    local value="${BASH_REMATCH[3]}"

    if (( abbrevOk )); then
        specAbbrev="${abbrev:1}" # `:1` to drop the slash.
    elif [[ ${abbrev} != '' ]]; then
        echo 1>&2 "Abbrev not allowed in spec: ${spec}"
        return 1
    fi

    if (( valueOk )); then
        specHasValue="$([[ ${value} == '' ]]; echo $?)"
        if (( specHasValue )); then
            specValue="${value:1}" # `:1` to drop the equal sign.
        fi
    elif [[ ${value} != '' ]]; then
        echo 1>&2 "Value not allowed in spec: ${spec}"
        return 1
    fi
}

# Sets the description of the named argument based on its type. This function
# will fail if an argument with the given name was already defined.
function _argproc_set-arg-description {
    local longName="$1"
    local typeName="$2"

    local funcName="_argproc:arg-description-${longName}"

    if declare -F "${funcName}" >/dev/null; then
        echo 1>&2 "Duplicate argument: ${longName}"
        return 1
    fi

    local desc
    case "${typeName}" in
        argument)
            desc="argument <${longName}>"
            ;;
        option)
            desc="option --${longName}"
            ;;
        *)
            echo 1>&2 "Unknown type: ${typeName}"
            return 1
            ;;
    esac

    eval 'function '"${funcName}"' {
        echo '"$(_argproc_quote "${desc}")"'
    }'
}

# Builds up a list of statements to evaluate, based on the given arguments. It
# is stored in the variable `_argproc_statements`, which is assumed to be
# declared by its caller.
#
# Note: This arrangement, where argument parsing is done in a separate
# function and as a separate pass from evaluation, makes it possible to use
# non-mangled local variables in the more tricky code, so it's a bit nicer to
# read.
function _argproc_statements-from-args {
    local argError=0
    local arg handler name statement value

    # This is used for required-argument checking.
    _argproc_statements+=($'local _argproc_receivedArgNames=\'\'')

    while (( $# > 0 )); do
        arg="$1"

        if [[ ${arg} == '--' ]]; then
            # Explicit end of options.
            shift
            break
        elif [[ ${arg} == '' || ${arg} =~ ^-[0-9]*$ || ${arg} =~ ^[^-] ]]; then
            # Non-option argument.
            break
        elif [[ ${arg} =~ ^--([-a-zA-Z0-9]+)(=.*)?$ ]]; then
            # Long-form argument.
            name="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"
            handler="_argproc:long-${name}"
            if ! declare -F "${handler}" >/dev/null; then
                echo 1>&2 "Unknown option: --${name}"
                argError=1
            elif [[ ${value} == '' ]]; then
                _argproc_statements+=("${handler}")
            else
                # `:1` to drop the `=` from the start of `value`
                _argproc_statements+=("${handler} $(_argproc_quote "${value:1}")")
            fi
        elif [[ $arg =~ ^-([a-zA-Z0-9]+)$ ]]; then
            # Short-form argument.
            arg="${BASH_REMATCH[1]}"
            while [[ ${arg} =~ ^(.)(.*)$ ]]; do
                name="${BASH_REMATCH[1]}"
                arg="${BASH_REMATCH[2]}"
                handler="_argproc:abbrev-${name}"
                if ! declare -F "${handler}" >/dev/null; then
                    echo 1>&2 "Unknown option: -${name}"
                    argError=1
                    # Break, to avoid spewing a ton of errors in case of a pilot
                    # error along the lines of `-longOptionName`.
                    break
                else
                    _argproc_statements+=("${handler}")
                fi
            done
        else
            # Something weird and invalid, e.g. `--=`.
            echo 1>&2 "Invalid option syntax: ${arg}"
            argError=1
        fi

        shift
    done

    for statement in "${_argproc_positionalFuncs[@]}"; do
        if (( $# == 0 )); then
            break
        fi

        _argproc_statements+=("${statement} $(_argproc_quote "$1")")
        shift
    done

    if declare -F _argproc:rest >/dev/null; then
        statement="_argproc:rest $(_argproc_quote "$@")"
        _argproc_statements+=("${statement}")
    elif (( $# > 0 )); then
        if (( ${#_argproc_positionalFuncs[@]} == 0 )); then
            echo 1>&2 'Non-option arguments are not allowed.'
        else
            echo 1>&2 'Too many arguments for command.'
        fi
        argError=1
    fi

    return "${argError}"
}

# Quotes one or more literal strings, space separated, so they can be safely
# used in evaluated code. This (successfully) prints nothing if no arguments are
# given.
function _argproc_quote {
    case "$#" in
        0)
            : # Nothing to print.
            ;;
        1)
            printf '%q' "$1"
            ;;
        *)
            printf '%q' "$1"
            shift
            printf ' %q' "$@"
            ;;
    esac
}
