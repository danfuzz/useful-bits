#!/bin/bash
#
# Copyright 2022 Dan Bornstein.
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Library for reasonably okay argument / option processing.
#
# Note: In places where this code expects to set global variables and call back
# to client code, care is taken to only define local variables with names that
# are unlikely to shadow globals. ("Hooray" for dynamic scoping!)
#

# List of default variable assignment statements.
_argproc_defaults=()


#
# Public functions
#

# Declares an "action" option, specified as `<name>/<abbrev>`, with `/<abbrev>`
# optional. `<abbrev>` specifies a single-dash single-character abbreviation for
# the option. At least one of `--call` or `--var` must be used to define the
# option.
#
# --call=<name> -- Calls the function with the given name. If `--var` is also
#   used, the call is made first, and then the variable is set only if the call
#   returned successfully.
# --var=<name> -- Sets the global `<name>` to `1`, and causes it to be
#   defaulted to `0` at the start of argument processing.
function opt-action {
    local callFunc=''
    local setVar=''

    while (( $# > 0 )); do
        case "$1" in
            --call=?*)
                callFunc="${1#*=}"
                ;;
            --var=?*)
                setVar="${1#*=}"
                ;;
            *)
                # End of options / unrecognized option.
                break
                ;;
        esac
        shift
    done

    local name="$1"

    if ! [[ ${name} =~ ^([a-zA-Z0-9][-a-zA-Z0-9]*)(/[a-zA-Z0-9])?$ ]]; then
        echo 1>&2 "Invalid option spec: ${name}"
        return 1
    fi

    name="${BASH_REMATCH[1]}"
    local abbrev="${BASH_REMATCH[2]}"

    if [[ ${callFunc} == '' && ${setVar} == '' ]]; then
        echo 1>&2 "Must use at least one of --call or --var for option: ${name}."
        return 1
    fi

    if [[ ${callFunc} != '' ]]; then
        # Re-form as the caller code.
        callFunc="${callFunc}"' || return "$?"'
    fi

    if [[ ${setVar} != '' ]]; then
        # Set up the default, and then re-form as the setter code.
        _argproc_defaults+=("${setVar}=0")
        setVar="${setVar}=1"
    fi

    eval 'function _argproc:long-'"${name}"' {
        if (( $# > 0 )); then
            echo 1>&2 "Value not allowed for option: --'"${name}"'"
            return 1
        fi

        '"${callFunc}"'
        '"${setVar}"'
    }'

    if (( ${#abbrev} == 2 )); then
        # `:1` to drop the slash.
        eval 'function _argproc:abbrev-'"${abbrev:1}"' {
            _argproc:long-'"${name}"' "$@"
        }'
    fi
}

# Declares a "choice" option set, specified as `<name>/<abbrev>=<value>`, with
# `<name>` required and the other two items optional. `<name>` is the full
# option name. `<abbrev>` specifies a single-dash single-character abbreviation
# for the option. `<value>` is the option value (which defaults to the full
# name). At least one of `--call` or `--var` must be used to define the option
# set.
#
# --call=<name> -- Calls the function with the given name, passing it the
#   option value. If `--var` is also used, the call is made first, and then the
#   variable is set only if the call returned successfully.
# --default=<value> -- The default value for the variable. If not specified, the
#   default value is `''` (the empty string).
# --var=<name> -- Sets the global `<name>` to the option value, and causes it to
#   be defaulted at the start of argument processing.
function opt-choice {
    local callFunc=''
    local defaultValue=''
    local setVar=''

    while (( $# > 0 )); do
        case "$1" in
            --call=?*)
                callFunc="${1#*=}"
                ;;
            --default=?*)
                defaultValue="${1#*=}"
                ;;
            --var=?*)
                setVar="${1#*=}"
                ;;
            *)
                # End of options / unrecognized option.
                break
                ;;
        esac
        shift
    done

    local specs=("$@")
    if (( ${#specs[@]} == 0 )); then
        echo 1>&2 'Missing option specs.'
        return 1
    fi

    if [[ ${callFunc} == '' && ${setVar} == '' ]]; then
        echo 1>&2 "Must use at least one of --call or --var for option: ${name}."
        return 1
    fi

    if [[ ${callFunc} != '' ]]; then
        # Re-form as the caller code.
        callFunc="${callFunc}"' "${_approc_value}" || return "$?"'
    fi

    if [[ ${setVar} != '' ]]; then
        # Set up the default, and then re-form as the setter code.
        _argproc_defaults+=("${setVar}=$(_argproc:quote "${defaultValue}")")
        setVar="${setVar}"'="${_argproc_value}"'
    fi

    local s
    for s in "${specs[@]}"; do
        if ! [[ ${s} =~ ^([a-zA-Z0-9][-a-zA-Z0-9]*)(/[a-zA-Z0-9])?(=(.*))?$ ]]; then
            echo 1>&2 "Invalid option spec: ${s}"
            return 1
        fi

        local name="${BASH_REMATCH[1]}"
        local abbrev="${BASH_REMATCH[2]:1}" # `:1` to drop the slash.
        local value="${BASH_REMATCH[3]:1}"    # Likewise.

        if [[ ${value} == '' ]]; then
            value="${name}"
        else
            value="$(_argproc:quote "${value}")"
        fi

        eval 'function _argproc:long-'"${name}"' {
            if (( $# > 0 )); then
                echo 1>&2 "Value not allowed for option: --'"${name}"'"
                return 1
            fi

            local _argproc_value='"${value}"'
            '"${callFunc}"'
            '"${setVar}"'
        }'

        if [[ ${abbrev} != '' ]]; then
            eval 'function _argproc:abbrev-'"${abbrev}"' {
                _argproc:long-'"${name}"' "$@"
            }'
        fi
    done
}

# Declares a "toggle" option, specified as `<name>/<abbrev>/<abbrev>`, with the
# two `/<abbrev>`s optional. `<abbrev>` specifies a single-dash single-character
# abbreviation for turning the toggle on (first one) or off (second one). In
# addition the long form `--no-<name>` gets defined to turn the toggle off. At
# least one of `--call` or `--var` must be used to define the option.
#
# --call=<name> -- Calls the function with the given name, passing it `1` or
#   `0`. If `--var` is also used, the call is made first, and then the variable
#   is set only if the call returned successfully.
# --var=<name> -- Sets the global `<name>` to `1` or `0`, and causes it to be
#   defauled to `0` at the start of argument processing.
function opt-toggle {
    local callFunc=''
    local setVar=''

    while (( $# > 0 )); do
        case "$1" in
            --call=?*)
                callFunc="${1#*=}"
                ;;
            --var=?*)
                setVar="${1#*=}"
                ;;
            *)
                # End of options / unrecognized option.
                break
                ;;
        esac
        shift
    done

    local name="$1"

    if ! [[ ${name} =~ ^([a-zA-Z0-9][-a-zA-Z0-9]*)(/[a-zA-Z0-9]?)?(/[a-zA-Z0-9])?$ ]]; then
        echo 1>&2 "Invalid option spec: ${name}"
        return 1
    fi

    name="${BASH_REMATCH[1]}"
    local abbrevOn="${BASH_REMATCH[2]}"
    local abbrevOff="${BASH_REMATCH[3]}"

    if [[ ${callFunc} == '' && ${setVar} == '' ]]; then
        echo 1>&2 "Must use at least one of --call or --var for option: ${name}."
        return 1
    fi

    if [[ ${callFunc} != '' ]]; then
        # Re-form as the caller code.
        callFunc="${callFunc}"' "${value}" || return "$?"'
    fi

    if [[ ${setVar} != '' ]]; then
        # Set up the default, and then re-form as the setter code.
        _argproc_defaults+=("${setVar}=0")
        setVar="${setVar}"'="$1"'
    fi

    eval '
        function _argproc:toggle-handler-'"${name}"' {
            if (( $# > 1 )); then
                echo 1>&2 "Value not allowed for option: --'"${name}"'"
                return 1
            fi

            '"${callFunc}"'
            '"${setVar}"'
        }

        function _argproc:long-'"${name}"' {
            _argproc:toggle-handler-'"${name}"' 1 "$@"
        }

        function _argproc:long-no-'"${name}"' {
            _argproc:toggle-handler-'"${name}"' 0 "$@"
        }
    '

    if (( ${#abbrevOn} == 2 )); then
        # `:1` to drop the slash.
        eval 'function _argproc:abbrev-'"${abbrevOn:1}"' {
            _argproc:toggle-handler-'"${name}"' 1
        }'
    fi

    if (( ${#abbrevOff} == 2 )); then
        # `:1` to drop the slash.
        eval 'function _argproc:abbrev-'"${abbrevOff:1}"' {
            _argproc:toggle-handler-'"${name}"' 0
        }'
    fi
}

# Declares a "value" option, specified as `<name>/<abbrev>`, with `/<abbrev>`
# optional. When parsed value options require a value, passed in the form
# `--<name>=<value>`. At least one of `--call` or `--var` must be used to define
# the option.
#
# --call=<name> -- Calls the function with the given name, passing it the option
#   value parsed from the argument. If `--var` is also used, the call is made
#   first, and then the variable is set only if the call returned successfully.
# --default=<value> -- The default value for the variable. If not specified, the
#   default value is `''` (the empty string).
# --match=<regex> -- Regular expression matched against the entire argument
#   value. If the value does not match, then the option gets rejected.
# --var=<name> -- Sets the global `<name>` to the value parsed from the
#   argument. This also causes the variable to be initialized at the start of
#   argument processing.
function opt-value {
    local callFunc=''
    local defaultValue=''
    local match=''
    local setVar=''

    while (( $# > 0 )); do
        case "$1" in
            --call=?*)
                callFunc="${1#*=}"
                ;;
            --default=?*)
                defaultValue="${1#*=}"
                ;;
            --match=?*)
                match="${1#*=}"
                ;;
            --var=?*)
                setVar="${1#*=}"
                ;;
            *)
                # End of options / unrecognized option.
                break
                ;;
        esac
        shift
    done

    local name="$1"

    if ! [[ ${name} =~ ^[a-zA-Z0-9][-a-zA-Z0-9]*$ ]]; then
        echo 1>&2 "Invalid option spec: ${name}"
        return 1
    fi

    if [[ ${callFunc} == '' && ${setVar} == '' ]]; then
        echo 1>&2 "Must use at least one of --call or --var for option: ${name}."
        return 1
    fi

    if [[ ${callFunc} != '' ]]; then
        # Re-form as the caller code.
        callFunc="${callFunc}"' "${value}" || return "$?"'
    fi

    if [[ ${setVar} != '' ]]; then
        # Set up the default, and then re-form as the setter code.
        _argproc_defaults+=("${setVar}=$(_argproc:quote "${defaultValue}")")
        setVar="${setVar}"'="$1"'
    fi

    if [[ ${match} != '' ]]; then
        # Re-form as the clause to insert to perform the check.
        match='
            elif ! [[ $1 =~ ^('"${match}"')$ ]]; then
                echo 1>&2 "Invalid value for option: --'"${name}"'"
                echo 1>&2 "Value: $1"
                return 1'
    fi

    eval 'function _argproc:long-'"${name}"' {
        if (( $# < 1 )); then
            echo 1>&2 "Value required for option: --'"${name}"'"
            return 1
        '"${match}"'
        fi

        '"${callFunc}"'
        '"${setVar}"'
    }'
}

# Processes all of the given arguments, according to the configured handlers.
# Returns non-zero if there is trouble parsing options or if any handler returns
# non-zero.
#
# Note: In addition to handlers defined by `opt-switch`, and `opt-value`, the
# handler `arg-rest`, if defined, is called with all arguments that remain after
# option processing. If not defined, it is considered an error to pass any
# non-option arguments.
function process-args {
    # Set all the defaults.
    local _argproc_d
    for _argproc_d in "${_argproc_defaults[@]}"; do
        eval "${_argproc_d}"
    done

    # Build up the statements to evaluate.
    local _argproc_statements=()
    _argproc:statements-from-args "$@"

    # Evaluate them!
    local _argproc_error=0
    local _argproc_s
    for _argproc_s in "${_argproc_statements[@]}"; do
        eval "${_argproc_s}" || _argproc_error="$?"
    done

    return "${_argproc_error}"
}

# Declares a "rest" argument, which gets all the non-option arguments during
# parsing. If not declared, argument processing will report an error if any
# non-option arguments are passed. At least one of the two options must be
# specified.
#
# --call=<name> -- Calls the function with the given name, passing it all the
#   non-option arguments. If `--var` is also used, the call is made first, and
#   then the variable is set only if the call returned successfully.
# --var=<name> -- Sets the global `<name>` to an array of all the non-option
#   arguments. This also causes the variable to be initialized to an empty
#   array at the start of argument processing.
function rest-arg {
    local callFunc=''
    local setVar=''

    while (( $# > 0 )); do
        case "$1" in
            --call=?*)
                callFunc="${1#*=}"
                ;;
            --var=?*)
                setVar="${1#*=}"
                ;;
            *)
                # End of options / unrecognized option.
                break
                ;;
        esac
        shift
    done

    if [[ ${callFunc} == '' && ${setVar} == '' ]]; then
        echo 1>&2 'Must use at least one of --call or --var for rest argument.'
        return 1
    fi

    if [[ ${callFunc} != '' ]]; then
        # Re-form as the caller code.
        callFunc="${callFunc}"' "$@" || return "$?"'
    fi

    if [[ ${setVar} != '' ]]; then
        # Set up the default, and then re-form as the setter code.
        _argproc_defaults+=("${setVar}=()")
        setVar="${setVar}"'=("$@")'
    fi

    eval 'function _argproc:rest {
        '"${callFunc}"'
        '"${setVar}"'
    }'
}


#
# Library-internal functions
#

# Builds up a list of statements to evaluate, based on the given arguments. It
# is stored in the variable `_argproc_statements`, which is assumed to be
# declared by its caller.
#
# Note: This arrangement, where argument parsing is done in a separate
# function and as a separate pass from evaluation, makes it possible to use
# non-mangled local variables in the more tricky code, so it's a bit nicer to
# read.
function _argproc:statements-from-args {
    local argError=0
    local arg handler name value

    while (( $# > 0 )); do
        arg="$1"

        if [[ ${arg} == '--' ]]; then
            # Explicit end of options.
            shift
            break
        elif [[ ${arg} == '-' || ${arg} =~ ^[^-] ]]; then
            # Non-option argument.
            break
        elif [[ ${arg} =~ ^--([-a-zA-Z0-9]+)(=.*)?$ ]]; then
            # Long-form argument.
            name="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"
            handler="_argproc:long-${name}"
            if ! declare -F "${handler}" >/dev/null; then
                echo 1>&2 "Unknown option: --${name}"
                argError=1
            elif [[ ${value} == '' ]]; then
                _argproc_statements+=("${handler}")
            else
                # `:1` to drop the `=` from the start of `value`
                _argproc_statements+=("${handler} $(_argproc:quote "${value:1}")")
            fi
        elif [[ $arg =~ ^-([a-zA-Z0-9]+)$ ]]; then
            # Short-form argument.
            arg="${BASH_REMATCH[1]}"
            while [[ ${arg} =~ ^(.)(.*)$ ]]; do
                name="${BASH_REMATCH[1]}"
                arg="${BASH_REMATCH[2]}"
                handler="_argproc:abbrev-${name}"
                if ! declare -F "${handler}" >/dev/null; then
                    echo 1>&2 "Unknown option: -${name}"
                    argError=1
                    # Break, to avoid spewing a ton of errors in case of a pilot
                    # error along the lines of `-longOptionName`.
                    break
                else
                    _argproc_statements+=("${handler}")
                fi
            done
        else
            # Something weird and invalid, e.g. `--=`.
            echo 1>&2 "Invalid option: ${arg}"
            argError=1
        fi

        shift
    done

    if declare -F _argproc:rest >/dev/null; then
        local statement="_argproc:rest $(_argproc:quote "$@")"
        _argproc_statements+=("${statement}")
    elif (( $# > 0 )); then
        echo 1>&2 'Non-option arguments are not allowed.'
        argError=1
    fi

    return "${argError}"
}

# Quotes one or more literal strings, space separated, so they can be safely
# used in evaluated code. This (successfully) prints nothing if no arguments are
# given.
function _argproc:quote {
    case "$#" in
        0)
            : # Nothing to print.
            ;;
        1)
            printf '%q' "$1"
            ;;
        *)
            printf '%q' "$1"
            shift
            printf ' %q' "$@"
            ;;
    esac
}


#
# TEST
#

opt-toggle --var=progress progress/p/P

opt-value --match='[a-z][-a-z0-9]*' --var=inLocation --call=set-location in
function set-location {
    echo 1>&2 ">>> SET LOCATION <<< ${inLocation} $1"
}

opt-value --var=name --default=$'no name' name

opt-action --call=usage --var=wantHelp help/h
function usage {
    echo 1>&2 '>>> THIS IS YOUR HELP! <<<' "${wantHelp}"
    exit
}

opt-choice --call=did-net --var=net tcp/t=floop-tcp udp/u zorp
function did-net {
    echo 1>&2 "####### GOT NET $1"
}

rest-arg --var=args --call=got-some-rest
function got-some-rest {
    echo "#### rest $#"
    if (( $# > 0 )); then
        printf $'>>%q<<\n' "$@"
    fi
    if (( $# == 4 )); then
        echo 1>&2 'REST ERROR!!!'
        return 1
    fi
}

echo 1>&2 '########## A'
process-args "$@"
error="$?"
echo 1>&2 "##### error? ${error}"
echo 1>&2 '########## B'

echo 1>&2 "#### progress ${progress}"
echo 1>&2 "#### in ${inLocation}"
echo 1>&2 "#### name >>>${name}<<<"
echo 1>&2 "#### net >>>${net}<<<"

if (( ${#args[@]} > 0 )); then
    printf $'arg >>%q<<\n' "${args[@]}"
fi

if (( error )); then
    exit "${error}"
fi

if [[ ${inLocation} == '' ]]; then
    echo 1>&2 'Missing required option: --in'
fi
